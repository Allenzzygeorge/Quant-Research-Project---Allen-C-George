import pandas as pd

# Path to your Parquet file
path = 'data1.parquet'

# Read the Parquet file
df = pd.read_parquet(path)


# Calculate the number of missing values in each column
missing_values = df.isnull().sum()

# Print the number of missing values in each column
print("Number of missing values in each column:")
print(missing_values)

#more detailed overview of the dataset
total_missing = missing_values.sum()
total_cells = df.size
missing_percentage = (total_missing / total_cells) * 100

print(f"\nTotal missing values: {total_missing}")
print(f"Total cells in dataset: {total_cells}")
print(f"Percentage of data missing: {missing_percentage:.2f}%")

import numpy as np

def custom_fill(series):
    """Custom function to fill missing values in a Series."""
    for i in range(len(series)):
        # Check if the current value is missing
        if pd.isnull(series[i]):
            # Check if 2 rows before and after are available and equal
            if i >= 2 and i <= len(series) - 3 and series[i-2] == series[i+2]:
                series[i] = series[i-2]  # Fill with the same value as 2 rows before
            else:
                # Compute mean of 3 rows above and below, excluding NaN
                surrounding_values = series[max(0, i-3):min(len(series), i+4)]
                mean_value = surrounding_values.mean()
                series[i] = mean_value
    return series

# Apply the custom filling function to the columns with missing values
df['banknifty'] = custom_fill(df['banknifty'])
df['nifty'] = custom_fill(df['nifty'])

#re-calculating the missing values

missing_values = df.isnull().sum()

print("Number of missing values in each column:")
print(missing_values)

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set the style of seaborn
sns.set(style="darkgrid")

# Time Series Plot for Bank Nifty and Nifty IVs
plt.figure(figsize=(10, 6))
plt.plot(df['tte'], df['banknifty'], label='Bank Nifty IV')
plt.plot(df['tte'], df['nifty'], label='Nifty IV')
plt.title('Implied Volatilities over Time')
plt.xlabel('Time')
plt.ylabel('Implied Volatility')
plt.legend()
plt.xticks(rotation=45)  # Rotate dates for better readability
plt.tight_layout()  # Adjust subplots to fit in the figure area.
plt.show()

# Histogram of the Spread
spread = df['banknifty'] - df['nifty']
plt.figure(figsize=(10, 6))
sns.histplot(spread, kde=True, bins=30)
plt.title('Histogram of IV Spread between Bank Nifty and Nifty')
plt.xlabel('Spread')
plt.ylabel('Frequency')
plt.show()

# Scatter Plot of IV Spread vs. Time To Expiry (TTE)
plt.figure(figsize=(10, 6))
plt.scatter(df['tte'], spread)
plt.title('IV Spread vs. Time To Expiry (TTE)')
plt.xlabel('Time To Expiry (TTE)')
plt.ylabel('IV Spread')
plt.show()

from scipy.stats import zscore

df['spread'] = df['banknifty'] - df['nifty']

# Calculate the rolling mean and standard deviation for the spread
window = 20  # The window can be changed based on how you define 'historical'
df['spread_mean'] = df['spread'].rolling(window=window).mean()
df['spread_std'] = df['spread'].rolling(window=window).std()

# Calculate the z-score
df['z_score'] = (df['spread'] - df['spread_mean']) / df['spread_std']

# Define entry and exit thresholds
entry_threshold = 2.0
exit_threshold = 0

# Identify trade entry and exit points
df['position'] = 0  # No position to start with
# Go long (buy) the spread when z_score is below the negative entry threshold
df.loc[df['z_score'] < -entry_threshold, 'position'] = 1
# Go short (sell) the spread when z_score is above the entry threshold
df.loc[df['z_score'] > entry_threshold, 'position'] = -1
# Exit positions when z_score crosses the exit threshold
df.loc[df['z_score'] * df['position'] < 0, 'position'] = 0

# Calculate P/L
# Assuming you enter/exit at the next available price, shift the positions by 1
df['next_position'] = df['position'].shift(1)
df['pl'] = df['spread'].diff() * df['next_position'] * (df['tte'] ** 0.7)

# Drop NaN values generated by diff() and shift()
df = df.dropna()

# Cumulative P/L for the strategy
df['cumulative_pl'] = df['pl'].cumsum()

# Print the DataFrame for inspection
print(df)

# Plot the cumulative P/L over time
df['cumulative_pl'].plot(title='Cumulative P/L for Z-Score Based Trading Strategy')
plt.xlabel('Time')
plt.ylabel('Cumulative P/L')
plt.show()
